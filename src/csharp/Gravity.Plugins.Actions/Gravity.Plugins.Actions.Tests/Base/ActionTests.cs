/*
 * CHANGE LOG - keep only last 5 threads
 * 
 * online resources
 * https://dev.to/franndotexe/mstest-v2---new-old-kid-on-the-block
 */
using Gravity.Plugins.Attributes;
using Gravity.Plugins.Base;
using Gravity.Plugins.Contracts;
using Gravity.Plugins.Engine;
using Gravity.Plugins.Extensions;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Newtonsoft.Json;
using OpenQA.Selenium;
using OpenQA.Selenium.Mock;
using OpenQA.Selenium.Mock.Extensions;
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;

namespace Gravity.Plugins.Actions.UnitTests.Base
{
    [DeploymentItem("Resources/license.lcn")]
    public abstract class ActionTests
    {
        #region *** constants      ***
        private const string ActionMethodName = "OnPerform";
        private const StringComparison Compare = StringComparison.OrdinalIgnoreCase;
        #endregion

        #region *** constructors   ***
        /// <summary>
        /// Creates a new instance of <see cref="ActionTests"/>
        /// </summary>
        protected ActionTests()
        {
            ClassSetup();
        }
        #endregion

        #region *** properties     ***
        /// <summary>
        /// Gets a basic <see cref="WebAutomation"/> instance for all tests in this domain.
        /// </summary>
        public WebAutomation Automation { get; private set; }

        /// <summary>
        /// Gets a new <see cref="MockWebDriver"/> instance or the last instance generated by <see cref="ActionFactory{T}"/>.
        /// </summary>
        public MockWebDriver WebDriver { get; set; }

        /// <summary>
        /// Gets the <see cref="System.Diagnostics.Stopwatch"/> object used by this <see cref="ActionTests"/>.
        /// </summary>
        public Stopwatch Stopwatch { get; private set; }
        #endregion

        #region *** execute plugin ***
        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <returns>A <see cref="Plugin"/> instance based on <see cref="ActionRule"/> execution.</returns>
        public Plugin ExecuteAction<T>() where T : Plugin
        {
            return DoExecuteAction<T>(
                by: default, actionRule: string.Empty, capabilities: null);
        }

        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <param name="actionRule">ActionRule JSON from which to create an <see cref="ActionRule"/> instance.</param>
        /// <returns>A <see cref="Plugin"/> instance based on <see cref="ActionRule"/> execution.</returns>
        public Plugin ExecuteAction<T>(string actionRule)
            where T : Plugin
        {
            return DoExecuteAction<T>(by: default, actionRule: actionRule, capabilities: null);
        }

        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <param name="capabilities"><see cref="MockCapabilities"/> capabilities by which to create the <see cref="MockWebDriver"/> of this action.</param>
        /// <returns>A <see cref="Plugin"/> instance based on <see cref="ActionRule"/> execution.</returns>
        public Plugin ExecuteAction<T>(IDictionary<string, object> capabilities)
            where T : Plugin
        {
            return DoExecuteAction<T>(by: default, actionRule: string.Empty, capabilities: capabilities);
        }

        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <param name="by">Provides a mechanism by which to find elements within a document.</param>
        /// <returns>A <see cref="Plugin"/> instance based on <see cref="ActionRule"/> execution.</returns>
        public Plugin ExecuteAction<T>(By by) where T : Plugin
        {
            return DoExecuteAction<T>(by: by, actionRule: string.Empty, capabilities: null);
        }

        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <param name="by">Provides a mechanism by which to find elements within a document.</param>
        /// <param name="actionRule">ActionRule JSON from which to create an <see cref="ActionRule"/> instance.</param>
        /// <returns>A <see cref="Plugin"/> instance based on <see cref="ActionRule"/> execution.</returns>
        public Plugin ExecuteAction<T>(By by, string actionRule)
            where T : Plugin
        {
            return DoExecuteAction<T>(by: by, actionRule: actionRule, capabilities: null);
        }

        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <param name="by">Provides a mechanism by which to find elements within a document.</param>
        /// <param name="capabilities"><see cref="MockCapabilities"/> capabilities by which to create the <see cref="MockWebDriver"/> of this action.</param>
        /// <returns>A <see cref="Plugin"/> instance based on <see cref="ActionRule"/> execution.</returns>
        public Plugin ExecuteAction<T>(By by, IDictionary<string, object> capabilities)
            where T : Plugin
        {
            return DoExecuteAction<T>(by: by, actionRule: string.Empty, capabilities: capabilities);
        }

        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <param name="actionRule">ActionRule JSON from which to create an <see cref="ActionRule"/> instance.</param>
        /// <param name="capabilities"><see cref="MockCapabilities"/> capabilities by which to create the <see cref="MockWebDriver"/> of this action.</param>
        /// <returns>A <see cref="Plugin"/> instance based on <see cref="ActionRule"/> execution.</returns>
        public Plugin ExecuteAction<T>(string actionRule, IDictionary<string, object> capabilities)
            where T : Plugin
        {
            return DoExecuteAction<T>(by: default, actionRule: actionRule, capabilities: capabilities);
        }

        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <param name="by">Provides a mechanism by which to find elements within a document.</param>
        /// <param name="actionRule">ActionRule JSON from which to create an <see cref="ActionRule"/> instance.</param>
        /// <param name="capabilities"><see cref="MockCapabilities"/> capabilities by which to create the <see cref="MockWebDriver"/> of this action.</param>
        /// <returns>A <see cref="Plugin"/> instance based on <see cref="ActionRule"/> execution.</returns>
        public Plugin ExecuteAction<T>(By by, string actionRule, IDictionary<string, object> capabilities)
            where T : Plugin
        {
            return DoExecuteAction<T>(by, actionRule, capabilities);
        }

        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <param name="actionRule">ActionRule JSON from which to create an <see cref="ActionRule"/> instance.</param>
        /// <param name="parameters">Perform method parameters list excluding <see cref="ActionRule"/> parameter type.</param>
        /// <returns>A collection of <see cref="OrbitResponse"/> based on <see cref="WebAutomation"/> execution.</returns>
        public IEnumerable<OrbitResponse> ExecuteAction<T>(string actionRule, object[] parameters)
            where T : Plugin
        {
            // setup
            var _actionRule = JsonConvert.DeserializeObject<ActionRule>(actionRule);
            _actionRule.ActionType = typeof(T).Name;

            // execute
            var executor = new AutomationExecutor(Automation);
            executor.Execute(automation: Automation, action: _actionRule, parameters);

            // results
            return executor.Responses.Select(i => i.Value);
        }

        /// <summary>
        /// Executes an action <see cref="Plugin"/> of the provided type.
        /// </summary>
        /// <typeparam name="T">The <see cref="Type"/> of action which will be executed.</typeparam>
        /// <param name="by">Provides a mechanism by which to find elements within a document.</param>
        /// <param name="actionRule">ActionRule JSON from which to create an <see cref="ActionRule"/> instance.</param>
        /// <param name="parameters">Perform method parameters list excluding <see cref="ActionRule"/> parameter type.</param>
        /// <returns>A collection of <see cref="OrbitResponse"/> based on <see cref="WebAutomation"/> execution.</returns>
        public IEnumerable<OrbitResponse> ExecuteAction<T>(By by, string actionRule, object[] parameters)
            where T : Plugin
        {
            // setup
            var _actionRule = JsonConvert.DeserializeObject<ActionRule>(actionRule);
            _actionRule.ActionType = typeof(T).Name;

            // setup: parameters
            var _parameters = by == default
                ? parameters
                : parameters.Concat(new object[] { WebDriver.FindElement(by) }).ToArray();

            // execute
            var executor = new AutomationExecutor(Automation);
            executor.Execute(automation: Automation, action: _actionRule, parameters: _parameters);

            // results
            return executor.Responses.Select(i => i.Value);
        }

        // executes an action plug-in of the provided type.
        private Plugin DoExecuteAction<T>(By by, string actionRule, IDictionary<string, object> capabilities)
            where T : Plugin
        {
            // setup
            var onActionRule = GetActionRule(actionRule);
            var plugin = ActionFactory<T>(Automation, capabilities);

            // setup conditions
            var isGeneric = plugin is GenericPlugin;
            var isWebDriver = plugin is WebDriverActionPlugin;

            // timer: setup
            Stopwatch.Restart();
            Stopwatch.Start();

            // execute
            try
            {
                if (isWebDriver)
                {
                    ExecuteWebDriverPlugin(plugin, actionRule: onActionRule, by);
                }

                if (isGeneric)
                {
                    ExecuteGenericPlugin(plugin, actionRule: onActionRule);
                }
            }
            finally
            {
                // timer: stop
                Stopwatch.Stop();
            }

            // return the executed plug-in instance.
            return plugin;
        }

        // executes web-driver action plugin
        private void ExecuteWebDriverPlugin(Plugin plugin, ActionRule actionRule, By by)
        {
            // get arguments
            var arguments = by == default
                ? new object[] { actionRule }
                : new object[] { actionRule, WebDriver.FindElement(by) };

            // execute
            ExecutePlugin(plugin, arguments);
        }

        // executes generic action plugin
        private static void ExecuteGenericPlugin(Plugin plugin, ActionRule actionRule)
        {
            // get arguments
            var arguments = actionRule == default
                ? null
                : new object[] { actionRule };

            // execute
            ExecutePlugin(plugin, arguments);
        }

        // executes action plugin
        private static void ExecutePlugin(Plugin plugin, object[] arguments)
        {
            try
            {
                // get method
                var method = Array
                    .Find(plugin.GetType().GetMethods(), i => IsActionPlugin(method: i, arguments));

                // execute
                method.Invoke(plugin, arguments);
            }
            catch (Exception e)
            {
                if (e.InnerException != null)
                {
                    throw e.InnerException;
                }
                throw;
            }
        }

        // assert method info for action plugin
        private static bool IsActionPlugin(MethodInfo method, object[] arguments)
        {
            // setup conditions
            var isName = method.Name.Equals(ActionMethodName, Compare);
            var isArguments = method.GetParameters().Length == arguments.Length;

            // assert
            return isName && isArguments;
        }
        #endregion

        #region *** documentation  ***
        /// <summary>
        /// Assert if an action <see cref="Plugin"/> documentation was correctly generated (!= default)
        /// and have loaded relevant properties.
        /// </summary>
        /// <typeparam name="T"><see cref="Plugin"/> type to generate.</typeparam>
        /// <param name="pluginName">The <see cref="Plugin"/> name to validate against the documentation.</param>
        public void AssertDocumentation<T>(string pluginName) where T : Plugin
        {
            DoAssertDocumentation<T>(pluginName, resource: default);
        }

        /// <summary>
        /// Assert if an action <see cref="Plugin"/> documentation was correctly generated (!= default)
        /// and have loaded relevant properties.
        /// </summary>
        /// <typeparam name="T"><see cref="Plugin"/> type to generate.</typeparam>
        /// <param name="pluginName">The <see cref="Plugin"/> name to validate against the documentation.</param>
        /// <param name="resource">Resource file name by which to Assert <see cref="PluginAttribute"/>.</param>
        public void AssertDocumentation<T>(string pluginName, string resource)
            where T : Plugin
        {
            DoAssertDocumentation<T>(pluginName, resource);
        }

        private void DoAssertDocumentation<T>(string pluginName, string resource)
            where T : Plugin
        {
            // get action
            var action = ActionFactory<T>(automation: Automation, capabilities: default);

            // get action attribute
            var attribute = action.GetType().GetCustomAttribute<PluginAttribute>();

            // verify resource
            if (!string.IsNullOrEmpty(resource))
            {
                var assembly = typeof(T).Assembly;
                var actionAttribute = ReadEmbeddedResource<PluginAttribute>(assembly, resource);
                var isName = attribute.Name.Equals(actionAttribute.Name);
                Assert.IsTrue(isName, "Plugin name does not match to action name in the resource file.");
            }

            // validation
            Assert.IsTrue(!string.IsNullOrEmpty(attribute.Description), "Plugin must have a description.");
            Assert.IsTrue(!string.IsNullOrEmpty(attribute.Summary), "Plugin must have a summary.");
            Assert.IsTrue(attribute.Name.Equals(pluginName), "Plugin name does not match to action name.");
            Assert.IsTrue(attribute.Examples.Length > 0, "Plugin must have at least one example.");
        }
        #endregion

        #region *** creation       ***
        /// <summary>
        /// Assert if a <see cref="Plugin"/> was correctly generated (!= default) and have loaded relevant properties.
        /// </summary>
        /// <typeparam name="T"><see cref="Plugin"/> type to generate.</typeparam>
        public void AssertPlugin<T>() where T : Plugin
        {
            // get action
            var action = ActionFactory<T>(automation: Automation, capabilities: default);

            // get properties
            var byFactory = action.GetType().GetProperty("ByFactory");
            var webDriver = action.GetType().GetProperty("WebDriver");

            // validation
            Assert.IsTrue(action != default, "Plugin was not generated correctly.");
            Assert.IsTrue(Plugin.Types.Count > 0, "Plugin types were not loaded.");

            if (action is WebDriverActionPlugin)
            {
                Assert.IsTrue(byFactory?.GetValue(action) != null, "Plugin ByFactory was not generated correctly.");
                Assert.IsTrue(webDriver?.GetValue(action) != null, "Plugin WebDriver was not generated correctly.");
            }
        }
        #endregion

        #region *** action rule    ***
        /// <summary>
        /// Gets an <see cref="ActionRule"/> object from <see cref="ActionRule"/> JSON (deserialize).
        /// </summary>
        /// <param name="actionRule"><see cref="ActionRule"/> JSON by which to create an <see cref="ActionRule"/> object.</param>
        /// <returns>A new <see cref="ActionRule"/> instance.</returns>
        public static ActionRule GetActionRule(string actionRule)
        {
            return string.IsNullOrEmpty(actionRule)
                ? new ActionRule()
                : JsonConvert.DeserializeObject<ActionRule>(actionRule);
        }
        #endregion

        #region *** action factory ***
        /// <summary>
        /// Generates <see cref="Plugin"/> instance based on the provided <see cref="Plugin"/> type.
        /// </summary>
        /// <typeparam name="T"><see cref="Plugin"/> type by which to generate a new <see cref="Plugin"/> instance.</typeparam>
        /// <returns><see cref="Plugin"/> instance of the specified type.</returns>
        public T ActionFactory<T>() where T : Plugin
        {
            return DoActionFactory<T>(Automation, capabilities: default);
        }

        /// <summary>
        /// Generates <see cref="Plugin"/> instance based on the provided <see cref="Plugin"/> type.
        /// </summary>
        /// <typeparam name="T"><see cref="Plugin"/> type by which to generate a new <see cref="Plugin"/> instance.</typeparam>
        /// <param name="automation"><see cref="WebAutomation"/> object by which to construct a new <see cref="Plugin"/> instance.</param>
        /// <returns><see cref="Plugin"/> instance of the specified type.</returns>
        public T ActionFactory<T>(WebAutomation automation)
            where T : Plugin
        {
            return DoActionFactory<T>(automation, capabilities: default);
        }

        /// <summary>
        /// Generates <see cref="Plugin"/> instance based on the provided <see cref="Plugin"/> type.
        /// </summary>
        /// <typeparam name="T"><see cref="Plugin"/> type by which to generate a new <see cref="Plugin"/> instance.</typeparam>
        /// <param name="automation"><see cref="WebAutomation"/> object by which to construct a new <see cref="Plugin"/> instance.</param>
        /// <param name="capabilities">Capabilities to add to the <see cref="Plugin"/> <see cref="IWebDriver"/> instance.</param>
        /// <returns><see cref="Plugin"/> instance of the specified type.</returns>
        public T ActionFactory<T>(WebAutomation automation, IDictionary<string, object> capabilities)
            where T : Plugin
        {
            return DoActionFactory<T>(automation, capabilities);
        }

        private T DoActionFactory<T>(WebAutomation automation, IDictionary<string, object> capabilities)
        {
            // setup
            if (capabilities != default)
            {
                WebDriver = WebDriver.ApplyCapabilities(capabilities);
            }

            // generate constructor arguments
            var arguments = WebDriver == default
                ? new object[] { automation }
                : new object[] { automation, WebDriver };

            // generate
            return (T)Activator.CreateInstance(typeof(T), arguments);
        }
        #endregion

        #region *** resources      ***
        /// <summary>
        /// Reads an embedded resource and attempts to deserialize it into the given type.
        /// </summary>
        /// <typeparam name="T">Object type to create based on the embedded resource.</typeparam>
        /// <param name="assembly"><see cref="Assembly"/> from which to read the resource.</param>
        /// <param name="name">Resource name. Name must match the resource file name.</param>
        public static T ReadEmbeddedResource<T>(Assembly assembly, string name)
        {
            // read
            var resource = ReadEmbeddedResource(assembly, name);

            // deserialize
            return resource.IsJson() ? JsonConvert.DeserializeObject<T>(resource) : default;
        }

        /// <summary>
        /// Reads an embedded resource.
        /// </summary>
        /// <param name="assembly">Assembly from which to read the resource.</param>
        /// <param name="name">Resource name, name must match the resource file name.</param>
        public static string ReadEmbeddedResource(Assembly assembly, string name)
        {
            return DoReadEmbeddedResource(assembly, name);
        }

        private static string DoReadEmbeddedResource(Assembly assembly, string name)
        {
            // exit conditions
            if (string.IsNullOrEmpty(name))
            {
                return string.Empty;
            }

            // assertion method
            static bool AssertName(string name, string fileName)
            {
                return name.EndsWith(fileName, Compare);
            }

            // search resource
            var fileReference = Array.Find(assembly.GetManifestResourceNames(), i => AssertName(i, name));

            // not found
            if (string.IsNullOrEmpty(fileReference))
            {
                return string.Empty;
            }

            // read
            var stream = assembly.GetManifestResourceStream(fileReference);
            using StreamReader reader = new StreamReader(stream);
            return reader.ReadToEnd();
        }
        #endregion

        #region *** testing        ***
        /// <summary>
        /// Executes a <see cref="TestMethodAttribute"/> a given number of attempts (if fails only).
        /// </summary>
        /// <param name="attempts">Number of attempts if the test fails.</param>
        /// <param name="test">Delegate to execute the test.</param>
        public static void Execute(int attempts, Action test)
        {
            for (int i = 0; i < attempts; i++)
            {
                try
                {
                    test.Invoke();
                    return;
                }
                catch (Exception e) when (e != null)
                {
                    Console.WriteLine($"Failed on attempt [{i + 1}] out of [{attempts}].");
                    if (i == attempts - 1)
                    {
                        throw;
                    }
                }
            }
        }
        #endregion

        #region *** utilities      ***
        /// <summary>
        /// Drops an existing SQL database.
        /// </summary>
        /// <param name="connectionString">SQL Database connection string.</param>
        public static void DropDatabase(string connectionString)
        {
            // setup
            var builder = new SqlConnectionStringBuilder(connectionString);
            var command =
                " USE [master]; " +
                $"IF EXISTS (SELECT [name] FROM sys.databases WHERE [name] = '{builder.InitialCatalog}')" +
                " BEGIN" +
                $"    ALTER DATABASE [{builder.InitialCatalog}] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;" +
                $"    DROP DATABASE [{builder.InitialCatalog}];" +
                " END";

            // clear initial catalog if exists
            builder.Remove("Initial Catalog");

            // setup connection
            using var connection = new SqlConnection(connectionString: builder.ConnectionString.Replace(@"\\", @"\"));
            connection.Open();

            // setup SQL command
            var sqlCommand = new SqlCommand(cmdText: "EXEC sp_executesql @script", connection);
            sqlCommand.Parameters.AddWithValue(parameterName: "script", value: command);

            // create database if not exists
            sqlCommand.ExecuteNonQuery();
        }
        #endregion

        #region *** setup: class   ***
        private void ClassSetup()
        {
            // setup: automation
            SetupWebAutomation();

            // setup: web driver
            WebDriver = new MockWebDriver();

            // setup: timer
            Stopwatch = new Stopwatch();
        }

        private void SetupWebAutomation()
        {
            // configuration
            var configuration = new EngineConfiguration
            {
                ElementSearchingTimeout = 100,
                PageLoadTimeout = 100
            };

            // authentication
            var authentication = new Authentication
            {
                UserName = "",
                Password = ""
            };

            // web automation default
            Automation = new WebAutomation
            {
                Authentication = authentication,
                EngineConfiguration = configuration
            };
        }
        #endregion
    }
}